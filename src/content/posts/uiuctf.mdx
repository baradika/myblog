---
title: "UIUCTF 2025"
description: "Write-up of UIUCTF 2025 challenges"
image: "../assets/uiu.png"
createdAt: 07-29-2025
draft: false
tags:
  - write-up
---

Today i wanna share a write-up of challs that i have been solved in `UIUCTF 2025` i played by myself and i really enjoyed the challenges, so let's start.


## crypto
### the shortest crypto chal

#### Challenge Overview

We are given the following Python code in `chal.py`:
```py
from Crypto.Cipher import AES
from hashlib import md5
from secret import a,b,c,d, FLAG

assert a**4 + b**4 == c**4 + d**4 + 17 and max(a,b,c,d) < 2e4 and AES.new( f"{a*b*c*d}".zfill(16).encode() , AES.MODE_ECB).encrypt(FLAG).hex() == "41593455378fed8c3bd344827a193bde7ec2044a3f7a3ca6fb77448e9de55155"
```
This script defines an assertion over 4 integers `a`, `b`, `c`, `d`, such that their fourth powers satisfy a specific relationship, and a given AES-ECB ciphertext must be the encryption of the flag using the key derived from `a*b*c*d`.

#### Observations
1. The flag is encrypted with AES in ECB mode.
2. The encryption key is derived by computing the product `a*b*c*d`, converting it to a zero-padded string of length 16.
3. The values `a, b, c, d` are all less than 20,000.
4. The equation to solve is: `a^4 + b^4 = c^4 + d^4 + 17` which is a Diophantine equation with a small offset.

This resembles a variation of the taxicab number problem (sums of two fourth powers), which is solvable by precomputing possibilities.

#### Strategy
To recover the plaintext flag:
1. Precompute all valid right-hand sides (RHS) of the equation `c^4 + d^4` for all `1 <= c,d < n` with `d <= c`
2. For each possible pair `(a, b)` (with `b <= a`), compute the left-hand side `a^4 + b^4 - 17`.
3. Binary search the RHS list for a match. If found:
* Compute the possible c and check if d^4 = lhs - c^4 gives an integer d.
4. If all constraints are met, compute `k = str(a*b*c*d).zfill(16).encode()` and decrypt the ciphertext.
5. If the plaintext starts with `uiuctf{`, we have found the correct key and decrypted the flag.

#### Solver
```python
from Crypto.Cipher import AES
from array import array
from bisect import bisect_left

n = 20000
fourth = [i**4 for i in range(n)]

# Precompute all c^4 + d^4 pairs
rhs = sorted(fourth[c] + fourth[d] for c in range(1, n) for d in range(1, c + 1))

ct = bytes.fromhex("41593455378fed8c3bd344827a193bde7ec2044a3f7a3ca6fb77448e9de55155")

for a in range(1, n):
    for b in range(1, a + 1):
        t = fourth[a] + fourth[b] - 17
        if t > rhs[-1]: break
        if rhs[bisect_left(rhs, t)] != t: continue
        for c in range(1, n):
            d4 = t - fourth[c]
            if d4 < 1: break
            d = round(d4 ** 0.25)
            if 1 <= d <= c and fourth[d] == d4:
                k = str(a * b * c * d).zfill(16).encode()
                pt = AES.new(k, AES.MODE_ECB).decrypt(ct)
                if pt.startswith(b'uiuctf{'):
                    print(pt.decode())
                    exit()
```
Flag: `uiuctf{D1oPh4nTine__Destr0yer__}`

### too many primes
#### Challenge Overview
We are given a file named `chal.py`:
```py
from sympy import nextprime, randprime
from sympy.core.random import seed
from math import prod, gcd
from Crypto.Util.number import bytes_to_long
# from secret import phi_N, FLAG

p = randprime(2**127, 2**128)
N = 1
while N < 2**2048:
        N *= p
        p = nextprime(p)

assert gcd(phi_N, 65537) == 1

pt = bytes_to_long(FLAG)
ct = pow(pt, 65537, N)
print("N = ", N)
print("ct = ", ct)
# N =  34546497157207880069779144631831207265231460152307441189118439470134817451040294541962595051467936974790601780839436065863454184794926578999811185968827621504669046850175311261350438632559611677118618395111752688984295293397503841637367784035822653287838715174342087466343269494566788538464938933299114092019991832564114273938460700654437085781899023664719672163757553413657400329448277666114244272477880443449956274432819386599220473627937756892769036756739782458027074917177880632030971535617166334834428052274726261358463237730801653954955468059535321422372540832976374412080012294606011959366354423175476529937084540290714443009720519542526593306377
# ct =  32130352215164271133656346574994403191937804418876038099987899285740425918388836116548661879290345302496993945260385667068119439335225069147290926613613587179935141225832632053477195949276266017803704033127818390923119631817988517430076207710598936487746774260037498876812355794218544860496013734298330171440331211616461602762715807324092281416443801588831683678783343566735253424635251726943301306358608040892601269751843002396424155187122218294625157913902839943220894690617817051114073999655942113004066418001260441287880247349603218620539692362737971711719433735307458772641705989685797383263412327068222383880346012169152962953918108171850055943194
```
So bacically we are given an RSA-like cryptosystem where the modulus `N` is constructed by multiplying multiple consecutive primes, starting from a 127-bit prime. The public exponent is the standard `e = 65537`, and we are provided with the ciphertext `ct`.

#### Observations
1. **Modulus Construction**:
* `N` is built by multiplying consecutive primes starting from a random prime `p` in the range `[2^127, 2^128)`.
* The multiplication continues until `N` reaches at least 2048 bits in size.
2. **Prime Count Estimation**:
* Since `(2^127)^17 ≈ 2^2159` (which is greater than `2^2048`), and `(2^127)^16 ≈ 2^2032` (which is less than `2^2048`), we deduce that `N` is the product of **17 consecutive primes**.
3. **Factoring Strategy:**:
* Given that `N` is the product of 17 consecutive primes, we can estimate the approximate value of the first prime by taking the 17th root of `N`.
* We then search for the exact starting prime within a reasonable range around this estimate.

#### Strategy
1. **Estimate the Starting Prime:**
* Compute the integer 17th root of `N` to get an approximate value for the first prime.
* Define a search window around this estimate (e.g., ±10000) to find the exact starting prime.
2. **Find Consecutive Primes:**
* For each candidate prime in the search window, generate the next 16 consecutive primes.
* Multiply these primes together and check if the product matches `N`.
3. **Compute Euler's Totient Function:**
* Once the primes are found, compute `phi(N)` as the product of `(p_i - 1)` for each prime `p_i`.
4. **Derive the Private Key:**
* Compute the modular inverse of `e` modulo `phi(N)` to get the private exponent `d`.
5. **Decrypt the Ciphertext:**
* Use the private exponent `d` to decrypt the ciphertext `ct` and recover the plaintext flag.

#### Solver
```python
from sympy import nextprime, isprime, integer_nthroot
from math import prod
from Crypto.Util.number import long_to_bytes

N = 34546497157207880069779144631831207265231460152307441189118439470134817451040294541962595051467936974790601780839436065863454184794926578999811185968827621504669046850175311261350438632559611677118618395111752688984295293397503841637367784035822653287838715174342087466343269494566788538464938933299114092019991832564114273938460700654437085781899023664719672163757553413657400329448277666114244272477880443449956274432819386599220473627937756892769036756739782458027074917177880632030971535617166334834428052274726261358463237730801653954955468059535321422372540832976374412080012294606011959366354423175476529937084540290714443009720519542526593306377
ct = 32130352215164271133656346574994403191937804418876038099987899285740425918388836116548661879290345302496993945260385667068119439335225069147290926613613587179935141225832632053477195949276266017803704033127818390923119631817988517430076207710598936487746774260037498876812355794218544860496013734298330171440331211616461602762715807324092281416443801588831683678783343566735253424635251726943301306358608040892601269751843002396424155187122218294625157913902839943220894690617817051114073999655942113004066418001260441287880247349603218620539692362737971711719433735307458772641705989685797383263412327068222383880346012169152962953918108171850055943194

m = 17
root, exact = integer_nthroot(N, m)
print(f"Root: {root}")

low = max(2**127, root - 10000)
high = root + 10000
print(f"Search window: {low} to {high}")

p0 = low
if p0 % 2 == 0:
    p0 += 1
found = False
factors = []

while p0 <= high:
    if isprime(p0):
        product = 1
        factors = []
        p = p0
        for i in range(m):
            factors.append(p)
            product *= p
            if product > N:
                break
            if i < m-1:
                p = nextprime(p)
        if product == N:
            found = True
            print(f"Found factors starting at {p0}")
            break
    p0 = nextprime(p0)

if not found:
    print("Factorization failed.")
    exit(1)

phi = 1
for p in factors:
    phi *= (p - 1)

e = 65537
d = pow(e, -1, phi)
pt = pow(ct, d, N)
flag = long_to_bytes(pt)
print(flag)
```
**Output:**
```txt
Root: 242444312856123694689611504831894231744
Search window: 242444312856123694689611504831894221744 to 242444312856123694689611504831894241744
Found factors starting at 242444312856123694689611504831894230373
b'uiuctf{D0nt_U5e_Cons3cUt1vE_PriMeS}'
```
Flag: `uiuctf{D0nt_U5e_Cons3cUt1vE_PriMeS}`

### back to roots
We are given a Python script (chal.py):
```py
from random import randint
from decimal import Decimal, getcontext
from hashlib import md5

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

from secret import FLAG

K = randint(10**10, 10**11)
print('K', K)
leak = int( str( Decimal(K).sqrt() ).split('.')[-1] )

print(f"leak = {leak}")
ct = AES.new(
        md5(f"{K}".encode()).digest(),
        AES.MODE_ECB
).encrypt(pad(FLAG, 16))

print(f"ct = {ct.hex()}")
```
and a `output.txt` file:
```txt
leak = 4336282047950153046404
ct = 7863c63a4bb2c782eb67f32928a1deceaee0259d096b192976615fba644558b2ef62e48740f7f28da587846a81697745
```
So the `chal.py` performs the following steps:
1. Generates a random integer `K` between `10^10` and `10^11`.
2. Computes the square root of `K` using high-precision arithmetic (`Decimal`).
3. Extracts the **fractional part** (22 digits after the decimal) of `√K` and leaks it.
4. Uses `K` to derive an AES key (via MD5) and encrypts the flag in ECB mode.

Our goal is to:
* **Recove** `K` from the leaked fractional part.
* **Decrypt** the ciphertext to obtain the flag.

#### Understanding the Leak
The leak is the **fractional part** of `√K`, stored as a 22-digit integer:
```txt
leak = 4336282047950153046404
```
This means:
```txt
√K ≈ n.4336282047950153046404
```
where `n` is the integer part of `√K`.

**Constraints**

* `K` is between `10^10` and `10^11`.
* Therefore, `√K` is between `10^5`(`100000.0`) and `~316227.766` (since `316227.766^2 ≈ 1e11`).

Thus, `n` (the integer part of `√K`) must be in `[100000, 316227]`.

#### Mathematical Approach to Recover `K`
We need to find `K` such that:
```txt
√K ≈ n + (leak / 10^22)
```
Squaring both sides:
```txt
K ≈ (n + (leak / 10^22))^2
```
Expending:
```txt
K ≈ n² + (2 * n * leak) / 10^22 + (leak² / 10^44)
```
Since `leak² / 10^44` is extremely small (~`1.88e-1`), we can approximate:
```text
K ≈ n² + (2 * n * leak) / 10^22
```
But `K` must be an integer, so:
```txt
K = round(n² + (2 * n * leak) / 10^22)
```
**Verification**

We can verify `K` by computing `√K` and checking if its fractional part matches the leak.

#### Algorithm to Find K
1. **Iterate over possible integer parts `n` (`100000 ≤ n ≤ 316227`).**
2. **Compute** `K` = `round(n² + (2 * n * leak) / 10^22)`. 
3. **Check if `K` is within bounds (`10^10 ≤ K ≤ 10^11`).**
4. **Compute `√K` with high precision** and extract the fractional part.
5. **Compare with the leak** to confirm correctness.

#### Solver
```python
from decimal import Decimal, getcontext
from hashlib import md5
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

def recover_K_and_decrypt(leak, ct_hex):
    M = 10**22
    n_min = 100000
    n_max = 316227

    for n in range(n_min, n_max + 1):
        # Compute K ≈ n² + (2 * n * leak) / 10^22
        K = round(n**2 + (2 * n * leak) / M)

        if K < 10**10 or K > 10**11:
            continue

        # Verify fractional part of √K matches leak
        getcontext().prec = 30
        sqrt_K = Decimal(K).sqrt()
        fractional_part = str(sqrt_K).split('.')[-1][:22]

        if len(fractional_part) < 22:
            fractional_part = fractional_part.ljust(22, '0')

        if int(fractional_part) == leak:
            # Decrypt the flag
            key = md5(str(K).encode()).digest()
            cipher = AES.new(key, AES.MODE_ECB)
            ct = bytes.fromhex(ct_hex)
            flag = unpad(cipher.decrypt(ct), 16).decode()
            return flag

    return None

leak = 4336282047950153046404
ct_hex = "7863c63a4bb2c782eb67f32928a1deceaee0259d096b192976615fba644558b2ef62e48740f7f28da587846a81697745"

flag = recover_K_and_decrypt(leak, ct_hex)
print(flag)
```
Flag: `uiuctf{SQu4Re_Ro0T5_AR3nT_R4nD0M}`

### symmetric
#### Challenge Overview
We are given a Python script (chal.py):
```py
from Crypto.Util.number import *
from secret import FLAG

p, q, r, s = [getPrime(512) for _ in "1234"]

print(f"h1 = {p + q + r + s}")
print(f"h2 = {p**2 + q**2 + r**2 + s**2}")
print(f"h3 = {p**3 + q**3 + r**3 + s**3}")

N = p*q*r*s
print(f"N = {N}")
pt = bytes_to_long(FLAG)
ct = pow(pt, 65537, N)
print(f"ct = {ct}")
```
and a `output.txt` file:
```txt
h1 = 44626154099651354925697068610752642661842459492769931945027538340211738148995902544351457443643808803963130274930824732652561687395268828472477422919262224
h2 = 516671113554555861164166966331322883848052630063409185414998284127910160310316421085219788291486248715029393774584960034375836715001130337767354512063372620828300201147366138270597133744747341658011663632381219284289144790858167258162656417236910634201286428763727072739569460623482985066956478781223378673732
h3 = 6147718474663450187001867904227777991349731066494841442199681943204194617136760567222545181562592364728655444222576167723225771866335920325045525027985716792468801076590684892140052786942251780392395274059384743594570343510311801194684613435002073956759521242578078411431891501758484581445964234548107005826532945720412531638919892681259687552977883437895032963223761216846303917338652743754915155934118353066174102436448393348040719582422022713292561416343278608
N = 14184841414933523698606245433393907034474143715949896731683874356940146602876788990832087413915033843120975580859113356518777762025417525571528638829956003882418585702756644491932279294535883798799580861254646149745925137179207140600356428758736111639677698862407787386573263961111978517446397007747429416079059195916290615125084899002162504424765939524455434579218079962808920072946861658695379491917567048202142417165204141307476222251547098848515065051745905180788313450494477967398727631152936238366581978379130450660235139256967936160718128731512409111209840405772933034600016694225294481603355934917366484109057
ct = 720607330561370237459911161481490697044029472780348552630924063963226757984368356580217337982783395620115957442082471977614781910209933696251479615689667675958354681196823652299435457532944189300223816303315625302472302494905575910600277892375951366031061219173465155686586206246661009612156094695841741309002508535764511343569015518587247600796520847856011377777228749182958947015029731456117404560626347774985507275302882865400315045173501559082431672490227728580592379740508214726249635835834752208899970446910850569489282065524329936561486377823093465841715608716032843259935185417766702677708267102415636848129
```
#### Observations
This challenge involves recovering four prime numbers from given power sums and their product. The ciphertext is encrypted using RSA, and the goal is to decrypt it to obtain the flag.
**Given Values:**
* `h1 = p + q + r + s`
* `h2 = p² + q² + r² + s²`
* `h3 = p³ + q³ + r³ + s³`
* `N = p * q * r * s`
* `ct = pow(FLAG, 65537, N)`

#### Strategy
1. **Compute Elementary Symmetric Sums**

Using Newton's identities, we derive the symmetric sums e1, e2, e3 from h1, h2, h3:
* `e1 = h1`
* `e2 = (e1² - h2) // 2`
* `e3 = (h3 - e1*h2 + e2*e1) // 3`

2. **Construct the Polynomial**

The primes `p, q, r, s` are roots of the polynomial:
`x⁴ - e1*x³ + e2*x² - e3*x + N`

3. **Find the roots** 

Solve the polynomial to obtain the four primes.

4. **Verify the Primes**

Ensure:
* Their product equals `N`.
* Their sum matches `h1`.

5. **Decrypt the Ciphertext**
* Compute `phi(N) = (p-1)(q-1)(r-1)(s-1)`
* Compute the private key `d = inverse(65537, phi(N))`
* Decrypt `ct` to get the flag.

#### Solver
```python
from Crypto.Util.number import long_to_bytes, inverse
import sympy

# Given values
h1 = 44626154099651354925697068610752642661842459492769931945027538340211738148995902544351457443643808803963130274930824732652561687395268828472477422919262224
h2 = 516671113554555861164166966331322883848052630063409185414998284127910160310316421085219788291486248715029393774584960034375836715001130337767354512063372620828300201147366138270597133744747341658011663632381219284289144790858167258162656417236910634201286428763727072739569460623482985066956478781223378673732
h3 = 6147718474663450187001867904227777991349731066494841442199681943204194617136760567222545181562592364728655444222576167723225771866335920325045525027985716792468801076590684892140052786942251780392395274059384743594570343510311801194684613435002073956759521242578078411431891501758484581445964234548107005826532945720412531638919892681259687552977883437895032963223761216846303917338652743754915155934118353066174102436448393348040719582422022713292561416343278608
N = 14184841414933523698606245433393907034474143715949896731683874356940146602876788990832087413915033843120975580859113356518777762025417525571528638829956003882418585702756644491932279294535883798799580861254646149745925137179207140600356428758736111639677698862407787386573263961111978517446397007747429416079059195916290615125084899002162504424765939524455434579218079962808920072946861658695379491917567048202142417165204141307476222251547098848515065051745905180788313450494477967398727631152936238366581978379130450660235139256967936160718128731512409111209840405772933034600016694225294481603355934917366484109057
ct = 720607330561370237459911161481490697044029472780348552630924063963226757984368356580217337982783395620115957442082471977614781910209933696251479615689667675958354681196823652299435457532944189300223816303315625302472302494905575910600277892375951366031061219173465155686586206246661009612156094695841741309002508535764511343569015518587247600796520847856011377777228749182958947015029731456117404560626347774985507275302882865400315045173501559082431672490227728580592379740508214726249635835834752208899970446910850569489282065524329936561486377823093465841715608716032843259935185417766702677708267102415636848129

# Compute elementary symmetric sums
e1 = h1
e2 = (e1 * e1 - h2) // 2
e3 = (h3 - e1 * h2 + e1 * e2) // 3

# Construct polynomial x⁴ - e1*x³ + e2*x² - e3*x + N
x = sympy.symbols('x')
poly = sympy.Poly(x**4 - e1*x**3 + e2*x**2 - e3*x + N, x)

# Find roots (primes)
roots = sympy.roots(poly, multiple=True)
primes = [int(r) for r in roots if r.is_integer and r > 0]

# Verify solution
assert len(primes) == 4
assert N == primes[0] * primes[1] * primes[2] * primes[3]
assert h1 == sum(primes)

# Compute phi(N) and decrypt
phi = 1
for p in primes:
    phi *= (p - 1)

d = inverse(65537, phi)
pt = pow(ct, d, N)
flag = long_to_bytes(pt)

# Output flag (handle non-UTF-8)
try:
    print(flag.decode())
except UnicodeDecodeError:
    print(flag.hex())
```
Flag: `uiuctf{5yMmeTRiC_P0lyS_FoRM_A_B4S15}`

## pwn
### QAS
So we are given a file named `handout.tar.gz` which contains a binary file, and the source code of the binary.
`chal.c`:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Quantum-grade type definitions for maximum security
typedef int not_int_small;
typedef short int_small;
typedef int not_int_big;
typedef not_int_small int_big;
typedef unsigned char quantum_byte;
typedef quantum_byte* quantum_ptr;

// Advanced authentication structures
typedef struct {
    not_int_big val;
} PASSWORD_QUANTUM;

typedef struct {
    int_small val;
    quantum_byte padding[2];
    quantum_byte checksum;
    quantum_byte reserved;
} INPUT_QUANTUM;

// Memory-aligned structure for optimal quantum processing
struct __attribute__((packed)) quantum_data_s {
    INPUT_QUANTUM input;
    PASSWORD_QUANTUM password;
    quantum_byte entropy_pool[8];
    quantum_byte quantum_state[16];
};

typedef struct quantum_data_s quantum_data_t;

// Quantum random number generator (patent pending)
static inline quantum_byte generate_quantum_entropy() {
    static quantum_byte seed = 0x42;
    seed = ((seed << 3) ^ (seed >> 5)) + 0x7f;
    return seed;
}

// Initialize quantum security subsystem
void init_quantum_security(quantum_data_t* qdata) {
    for (int i = 0; i < 8; i++) {
        qdata->entropy_pool[i] = generate_quantum_entropy();
    }

    // Initialize quantum state with pseudo-random values
    for (int i = 0; i < 16; i++) {
        qdata->quantum_state[i] = (quantum_byte)(i * 0x11 + 0x33);
    }

    qdata->input.padding[0] = 0;
    qdata->input.padding[1] = 0;
}

// Quantum hash function (revolutionary technology)
not_int_big quantum_hash(INPUT_QUANTUM input, quantum_byte* entropy) {
    int_small input_val = input.val;
    not_int_big hash = input_val;

    // Apply quantum transformation matrix
    hash ^= (entropy[0] << 8) | entropy[1];
    hash ^= (entropy[2] << 4) | (entropy[3] >> 4);
    hash += (entropy[4] * entropy[5]) & 0xff;
    hash ^= entropy[6] ^ entropy[7];
    hash |= 0xeee;
    hash ^= input.padding[0] << 8 | input.padding[1];

    return hash;
}

// Decrypt the victory condition
void access_granted() {
    printf("Quantum authentication successful!\n");
    printf("Accessing secured vault...\n");

    FILE *fp = fopen("flag.txt", "r");
    if (fp == NULL) {
        printf("Error: Quantum vault is offline\n");
        printf("Please contact the quantum administrator.\n");
        return;
    }

    char flag[100];
    if (fgets(flag, sizeof(flag), fp) != NULL) {
        printf("CLASSIFIED FLAG: %s\n", flag);
    } else {
        printf("Error: Quantum decryption failed\n");
        printf("Please contact the quantum administrator.\n");
    }
    fclose(fp);
}

int main() {
    quantum_data_t qdata;

    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    // Initialize quantum security subsystem
    init_quantum_security(&qdata);

    // Set quantum password (TODO: implement proper quantum key derivation)
    qdata.password.val = 0x555;

    printf("=== QUANTUM AUTHENTICATION SYSTEM v2.7.3 ===\n");
    printf("Initializing quantum security protocols...\n");

    // Simulate quantum initialization delay
    for (volatile int i = 0; i < 100000; i++) { /* quantum processing */ }

    printf("Quantum entropy generated. System ready.\n");
    printf("Please enter your quantum authentication code: ");

    // Read user input
    if (scanf("%d", (int*)&qdata.input.val) != 1) {
        printf("Invalid quantum input format!\n");
        return 1;
    }

    // Calculate input checksum for integrity
    qdata.input.checksum = (quantum_byte)(qdata.input.val & 0xff);

    // Apply quantum hash transformation
    not_int_big hashed_input = quantum_hash(qdata.input, qdata.entropy_pool);

    printf("Quantum hash computed: 0x%x\n", hashed_input);

    // Verify quantum authentication
    if (hashed_input == qdata.password.val) {
        access_granted();
    } else {
        printf("Quantum authentication failed!\n");
        printf("Access denied. Incident logged.\n");
    }

    return 0;
}
```
and also i decided to check the protection of the binary file, so i used `checksec`:
```bash
❯ checksec --file chal
[*] '/home/b4r/ctf/uiuctf/pwn/qas/handout/chal'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
* **No PIE**: Code segments at fixed addresses.
* **Stack Canary**: Prevents traditional stack overflows
* **NX**: Shellcode injection not possible

### Vulnerabilities
The main vulnerability lies in how the program handles user input:
```c
if (scanf("%d", (int*)&qdata.input.val) != 1) {
    printf("Invalid quantum input format!\n");
    return 1;
}
```
1. The program reads a signed integer (`%d`) but stores it in a short (2-byte) field
2. This causes an integer overflow that affects adjacent fields:
```c
typedef struct {
    int_small val;        // 2 bytes
    quantum_byte padding[2]; // 2 bytes
    quantum_byte checksum;
    quantum_byte reserved;
} INPUT_QUANTUM;
```
### Exploitation
1. The `quantum_hash` function performs several operations using:
* Input value (`input.val`)
* Entropy pool (8 pseudo-random bytes)
* Padding bytes (input.padding)

2. By providing a 4-byte integer, we can:
* Set `input.val` (first 2 bytes)
* Control `input.padding` (next 2 bytes)

3. We need to find padding values that make the final hash equal to `0x555`.

### Solution
The entropy pool is generated using a predictable PRNG:
```py
def generate_entropy():
    entropy = []
    seed = 0x42
    for _ in range(8):
        seed = ((seed << 3) ^ (seed >> 5)) + 0x7f
        seed &= 0xff
        entropy.append(seed)
    return entropy

entropy = [0x91, 0x0b, 0xd7, 0x3d, 0x68, 0xc2, 0x95, 0x2b]
```
The hash computation follows these steps:
1. Start with input value (`T`)
2. XOR with (`entropy[0]<<8 | entropy[1]`)
3. XOR with (`entropy[2]<<4 | entropy[3]>>4`)
4. Add (`entropy[4]*entropy[5] & 0xff`)
5. XOR with (`entropy[6]^entropy[7]`)
6. OR with `0xeee`
7. XOR with (`padding[0]<<8 | padding[1]`)

We want final_hash = `0x555`. Using T=0:
```py
h = 0
h ^= 0x910b        # Step 2 → 0x910b
h ^= 0xd73         # Step 3 → 0x9e78
h += (0x68*0xc2) & 0xff # Step 4 → 0x9f48
h ^= 0xbe          # Step 5 → 0x9ff6
h |= 0xeee         # Step 6 → 0x9ffe
required_padding = h ^ 0x555 # → 0x9aab
```
To construct the final input, we need to send an integer where:
* First 2 bytes = input value (`0`)
* Next 2 bytes = padding (`0x9aab`)
```py
input_val = 0
padding = 0x9aab
exploit_int = input_val | (padding << 16)
# Convert to signed 32-bit integer
if exploit_int > 0x7fffffff:
    exploit_int -= 0x100000000
# Result: -1414594560
```
### Final Exploit  
```py
entropy = []
seed = 0x42
for i in range(8):
    seed = ((seed << 3) ^ (seed >> 5)) + 0x7f
    seed &= 0xff  # Keep only the lower byte
    entropy.append(seed)

T = 0  # We'll use 0 for input.val

# Step-by-step hash calculation
h = T
# Step 2: XOR with entropy[0:1]
h ^= (entropy[0] << 8) | entropy[1]
# Step 3: XOR with entropy[2:3]
val3 = (entropy[2] << 4) | (entropy[3] >> 4)
h ^= val3
# Step 4: Add product of entropy[4] and entropy[5]
mul = entropy[4] * entropy[5]
h += mul & 0xff
# Step 5: XOR with entropy[6]^entropy[7]
xor5 = entropy[6] ^ entropy[7]
h ^= xor5
# Step 6: OR with 0xeee
h |= 0x0eee

# Calculate required padding
P = h ^ 0x555  # P = (hash_so_far ^ desired_hash)
P &= 0xffff     # Ensure it's 16-bit

# Build the input integer
p0 = (P >> 8) & 0xff  # High byte of padding
p1 = P & 0xff         # Low byte of padding
integer = T | (p0 << 16) | (p1 << 24)

# Convert to signed integer
if integer > 0x7fffffff:
    integer -= 0x100000000

print(integer)
```
**Output:**
```txt
-1415970816
```
Try first on local:
```bash
❯ ./chal
=== QUANTUM AUTHENTICATION SYSTEM v2.7.3 ===
Initializing quantum security protocols...
Quantum entropy generated. System ready.
Please enter your quantum authentication code: -1415970816
Quantum hash computed: 0x555
Quantum authentication successful!
Accessing secured vault...
Error: Quantum vault is offline
Please contact the quantum administrator.
```
Its correct! Let's try on the server:
```bash 
❯ ncat --ssl qas.chal.uiuc.tf 1337
== proof-of-work: disabled ==
=== QUANTUM AUTHENTICATION SYSTEM v2.7.3 ===
Initializing quantum security protocols...
Quantum entropy generated. System ready.
Please enter your quantum authentication code: -1415970816
Quantum hash computed: 0x555
Quantum authentication successful!
Accessing secured vault...
CLASSIFIED FLAG: uiuctf{qu4ntum_0v3rfl0w_2d5ad975653b8f29}
```
Flag: `uiuctf{qu4ntum_0v3rfl0w_2d5ad975653b8f29}`

## rev
### flag_checker

So we are given a binary named `flagchecker`, so i decided to decompile it.
```c
undefined8 main(void)

{
  char cVar1;
  long in_FS_OFFSET;
  undefined1 local_38 [40];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  get_input(local_38);
  cVar1 = check_input(local_38);
  if (cVar1 != '\0') {
    puts("PRINTING FLAG: ");
    print_flag(local_38);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
```c
void get_input(long param_1)

{
  int local_10;
  int local_c;
  
  for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {
    printf("> ");
    __isoc99_scanf(&DAT_001020a3,param_1 + (long)local_10 * 4);
  }
  for (local_c = 0; local_c < 8; local_c = local_c + 1) {
    *(uint *)((long)local_c * 4 + param_1) = *(uint *)(param_1 + (long)local_c * 4) % 0xffffff2f;
  }
  return;
}
```
```c
undefined8 check_input(long param_1)

{
  int iVar1;
  int local_10;
  
  local_10 = 0;
  while( true ) {
    if (7 < local_10) {
      return 1;
    }
    iVar1 = F(*(undefined4 *)(test_pt + (long)local_10 * 4),
              *(undefined4 *)(param_1 + (long)local_10 * 4),0xffffff2f);
    if (iVar1 != *(int *)(test_ct + (long)local_10 * 4)) break;
    local_10 = local_10 + 1;
  }
  return 0;
}
```
```c
ulong F(long param_1,ulong param_2,ulong param_3)

{
  undefined8 local_28;
  undefined8 local_18;
  undefined8 local_10;
  
  local_18 = 1;
  local_10 = param_1 % (long)param_3;
  for (local_28 = param_2; 0 < (long)local_28; local_28 = (long)local_28 >> 1) {
    if ((local_28 & 1) != 0) {
      local_18 = (local_18 * local_10) % param_3;
    }
    local_10 = (local_10 * local_10) % param_3;
  }
  return local_18;
}
```
You have to enter 8 numbers `x[0]..x[7]` (each number is taken mod `0xffffff2f`)
```c 
F(test_pt[i], x[i], 0xffffff2f) == test_ct[i] 
```
Then the value of `x[0]..x[7]` will be used to decrypt `flag_enc`

**function F:**
```c
ulong F(base, exp, mod) {
    ulong res = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp & 1)
            res = (res * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return res;
}
```
That's **modular exponentiation**:
```c
F(a, b, p) = pow(a, b, p)
```
Find the array `x[0..7] ∈ [0, 0xffffff2f)` so that:
```c
pow(test_pt[i], x[i], 0xffffff2f) == test_ct[i]
```
In other words, we need to:
```c
x[i] == discrete_log(test_pt[i], test_ct[i], 0xffffff2f)
```
First, we need to find the values of `test_pt` and `test_ct` from the memory dump by using signature `flag_enc` from `.rodata` section:
```c
                             test_pt                                         XREF[3]:     Entry Point(*), 
                                                                                          check_input:0010131f(*), 
                                                                                          check_input:00101326(*)  
        00102040 f5 b1 65        undefine
                 22 4a 58 
                 b7 91 df 
                             test_ct                                         XREF[3]:     Entry Point(*), 
                                                                                          check_input:00101349(*), 
                                                                                          check_input:00101350(*)  
        00102060 5e bf 44        undefine
                 dc ec 1c 
                 ff 5a c2 
                             flag_enc                                        XREF[3]:     Entry Point(*), 
                                                                                          print_flag:001013c4(*), 
                                                                                          print_flag:001013cb(*)  
        00102080 11 91 18        undefine
                 24 45 e9 
                 94 fd a6 
```
```python
from pwn import *

e = ELF('./flagchecker', checksec=False)
needle = bytes([0x11, 0x91, 0x18, 0x24, 0x45, 0xe9, 0x94, 0xfd])
addr = e.search(needle).__next__()
print(f"Found flag_enc at file offset: {hex(addr)}")
flag_enc_offset = addr
test_ct_offset = flag_enc_offset - 0x20 
test_pt_offset = flag_enc_offset - 0x40 
test_pt = [u32(e.read(test_pt_offset + i*4, 4)) for i in range(8)]
test_ct = [u32(e.read(test_ct_offset + i*4, 4)) for i in range(8)]
print("test_pt =", test_pt)
print("test_ct =", test_ct)
```
**Output:**
```txt
Found flag_enc at file offset: 0x2080
test_pt = [577090037, 2444712010, 3639700191, 3445702192, 3280387012, 271041745, 1095513148, 506456969]
test_ct = [3695492958, 1526668524, 3790189762, 20093842, 2409408810, 239453620, 1615481745, 1887562585]
```
We already have `test_pt`, `test_ct`, and `mod = 0xffffff2f = 4294967087`, just solve the equation:
```python
pow(test_pt[i], x[i], mod) == test_ct[i]
```
which means we need a discrete log:
```python
x[i] = discrete_log(mod, test_ct[i], test_pt[i])
```
But because the mod is so big (32-bit prime), discrete_log will take a long time using the general method. So we use Baby-step Giant-step (BSGS) to find the discrete log (https://en.wikipedia.org/wiki/Baby-step_giant-step) This is much faster than brute-force and can handle large moduli like `0xffffff2f`
Here is the implementation:
```python
mod = 0xffffff2f

test_pt = [577090037, 2444712010, 3639700191, 3445702192, 3280387012, 271041745, 1095513148, 506456969]
test_ct = [3695492958, 1526668524, 3790189762, 20093842, 2409408810, 239453620, 1615481745, 1887562585]

from math import isqrt

def bsgs(g, h, p):
    m = isqrt(p) + 1
    table = {}
    baby = 1
    for j in range(m):
        if baby not in table:
            table[baby] = j
        baby = (baby * g) % p

    g_m_inv = pow(g, -m, p)
    giant = h
    for i in range(m):
        if giant in table:
            return i * m + table[giant]
        giant = (giant * g_m_inv) % p
    return None

x = []
for i in range(8):
    xi = bsgs(test_pt[i], test_ct[i], mod)
    if xi is None:
        print(f"FAILED at index {i}")
    else:
        print(f"x[{i}] = {xi}")
        x.append(xi)
```
**Output**:
```txt
x[0] = 2127877499
x[1] = 1930549411
x[2] = 2028277857
x[3] = 2798570523
x[4] = 901749037
x[5] = 1674216077
x[6] = 3273968005
x[7] = 3294916953
```
### Solve
```bash
❯ ./flagchecker
> 2127877499
> 1930549411
> 2028277857
> 2798570523
> 901749037
> 1674216077
> 3273968005
> 3294916953
PRINTING FLAG:
sigpwny{CrackingDiscreteLogs4TheFun/Lols؂���}
```
Flag: `sigpwny{CrackingDiscreteLogs4TheFun}`


